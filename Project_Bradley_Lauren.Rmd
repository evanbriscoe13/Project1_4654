---
title: "Lauren_bradley_proj1"
author: "Lauren Bradley"
date: "10/21/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Your function will have the following inputs.
# 
# * x - a numeric input vector
# * y - a numeric response
#
# Note span and degree are shown with their default values. (Read about this in the description)
# * degree should be 1 or 2 only
# * span can be any value in interval (0, 1) non-inclusive.
#
# If show.plot = TRUE then you must show a plot of either the final fit
myloess <- function(x, y, span = 0.5, degree = 1, show.plot = TRUE){
  
  # Your code goes here
  #N_total
  N_total <- length(x)
  #n_points
  n_points <- ceiling(length(y)*span)
  #Our fitted values vector
  y.fitted <- double(length = length(y))
  #past local subset
  past_loc_dat <- double(length = n_points)
  #Win_total
  Win_total = 0
  # Degree 2
  if(degree == 2){
    for (val in x){
      #Create current local subset vector
      loc_dat <- create_subset(val, x, y, n_points)
      #Compare to previous local subset
      # If previous local dataset is not equal to current
      if(!setequal(loc_dat$x, past_loc_dat)){
        Win_total = Win_total + 1
        past_loc_dat <- loc_dat$x
      }
      #calculate distance vector
      distances <- loc_dat$dist
      max.dist <- max(distances)
      #calculate scaled distances vector
      scale_dists <- distances/max.dist
      # call weight function to make vector
      wts <- triwts(scale_dists)
       #conduct weighted regression
      fit <- lm(y~ x + x**2, weights = wts, data = loc_dat)
      #calculate predicted value from regression fit and coefficients
      reg.value <- fit$coefficients[1] + fit$coefficients[2]*val +fit$coefficients[3]*val**2
      #Add to fitted values vector
      y.fitted <- append(y.fitted, reg.value)
    }
    
  }
  # Degree 1
  else{
    
    #Go through each point
    for (val in x){
      
      #Create current local subset vector
      loc_dat <- create_subset(val, x,y, n_points)
      #Compare to previous local subset
      # If previous local dataset is not equal to current
      if(!setequal(loc_dat$x, past_loc_dat)){
        Win_total = Win_total + 1
        past_loc_dat <- loc_dat$x
      }
      #calculate distance vector
      distances <- loc_dat$dist
      max.dist <- max(distances)
      #calculate scaled distances vector
      scale_dists <- distances/max.dist
      # call weight function to make vector
      wts <- triwts(scale_dists)
      #conduct weighted regression
      fit <- lm(y~ x, weights = wts, data = loc_dat)
      #calculate predicted value from regression fit and coefficients
      reg.value <- fit$coefficients[1] + fit$coefficients[2]*val
      #Add to fitted values vector
      y.fitted <- append(y.fitted, reg.value)
    }
    SSE <- sum((y-y.fitted)**2)
  }
  
  #loessplot <- ggplot(aes(x = x, y = y)) + theme_bw() + geom_point() + 
  #            geom_line(color='red', aes(x= x, y=y.fitted))
  
  ls <- list('Span' = span, 'degree' = degree, 'N_total' = N_total, 'Win_total' = Win_total, 'n_points' = n_points, 'SSE' = SSE)
    
  return (ls)
}
# Your function should return a named list containing the following:
# span: proportion of data used in each window (controls the bandwidth)
# degree: degree of polynomial
# N_total: total number of points in the data set
# Win_total: total number of windows
# n_points: number of points in each window in a vector
# SSE: Error Sum of Squares (Tells us how good of a fit we had).
# loessplot: An object containing the ggplot so that we can see the plot later. 
#  We want this even if show.plot = FALSE
#  Note: you are NOT allowed to simply use stat_smooth() or geom_smooth() to have it automatically do LOESS.
#  You should use geom_line() or similar to plot your final the LOESS curve.

# Make sure you can access the objects properly using the $ notation.
```

```{r local_subset}
create_subset <- function(obs, x, y, k){
  sub_df <- data.frame(x = x, y=y, dist = abs(obs-x))
  sub_df <- sub_df[order(sub_df$dist),]
  sub_df <- sub_df[1:k,]
  sub_df <- sub_df[order(sub_df$x),]
  return (sub_df)
}

```


```{r weight function}
triwts <- function(distances){
  #allocate weights vector
  wts <- double(length = length(distances))
  
  for (i in 1:length(distances)){
    if (abs(distances[i]) <= 1){
      wts[i] <- (1-abs(distances[i])**3)**3
    }
    else
      wts[i] <- 0
  }
  return (wts)
}
dist <- c(0.7866237, 0.3744029, 0.168412, 0.0000000, 0.6660479, 0.7498743, 1.0000000)
triwts(dist)
```


```{r}
library(ggplot2)
load("ozone.RData")
data("ozone")

ggplot(ozone, aes(x = temperature, y = ozone)) + theme_bw() + geom_point()
```

```{r}
poly1 <- lm(ozone ~ temperature, data = ozone)
predicted_df <- data.frame(mpg_pred = predict(poly1, ozone), temp=ozone$)

ggplot(ozone, aes(x = temperature, y = ozone)) + theme_bw() + geom_point()
  + geom_line(color='red', data = ozone, aes(x= poly1))

```



