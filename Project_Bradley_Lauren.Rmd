---
title: "Lauren_bradley_proj1"
author: "Lauren Bradley"
date: "10/21/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Your function will have the following inputs.
# 
# * x - a numeric input vector
# * y - a numeric response
#
# Note span and degree are shown with their default values. (Read about this in the description)
# * degree should be 1 or 2 only
# * span can be any value in interval (0, 1) non-inclusive.
#
# If show.plot = TRUE then you must show a plot of either the final fit
myloess <- function(x, y, span = 0.5, degree = 1, show.plot = TRUE){
  #
  # Your code goes here
  #N_total
  N_total <- length(x)
  #n_points
  n_points <- ceiling(length(y)/span)
  #Our fitted values vector
  y.fitted <- double(length = length(y))
  # Degree 2
  if(degree == 2){
    for (val in x){
      loc_dat <- create_subset(val, x, n_point)
      distances <- abs(loc_dat-val)
      max.dist <- max(distances)
      scale_dists <- distances/max.dist
      wts <- triwts(scale_dists)
      fit <- lm(y~ x + x**2, weights = wts)
      reg.value <- fit$coefficients[1] + fit$coefficients[2]*val +fit$coefficients[3]*val**2
      y.fitted <- append(y.fitted, reg.value)
    }
    
  }
  # Degree 1
  else{
    #Go through each point
    for (val in x){
      loc_dat <- create_subset(val, x, n_point)
      distances <- abs(loc_dat-val)
      max.dist <- max(distances)
      scale_dists <- distances/max.dist
      wts <- triwts(scale_dists)
      fit <- lm(y~ x, weights = wts)
      reg.value <- fit$coefficients[1] + fit$coefficients[2]*val
      y.fitted <- append(y.fitted, reg.value)
    }
    SSE <- (y-y.fitted)**2
  }
    
  return c(span, degree, N_total, Win_total, n_points, SSE, loessplot)
}
# Your function should return a named list containing the following:
# span: proportion of data used in each window (controls the bandwidth)
# degree: degree of polynomial
# N_total: total number of points in the data set
# Win_total: total number of windows
# n_points: number of points in each window in a vector
# SSE: Error Sum of Squares (Tells us how good of a fit we had).
# loessplot: An object containing the ggplot so that we can see the plot later. 
#  We want this even if show.plot = FALSE
#  Note: you are NOT allowed to simply use stat_smooth() or geom_smooth() to have it automatically do LOESS.
#  You should use geom_line() or similar to plot your final the LOESS curve.

# Make sure you can access the objects properly using the $ notation.
```

```{r local_subset}
create_subset <- function(obs, vector, k){
  return(vector[order(abs(obs-vector))][seq_len(k)])
}
x <- c(1,2,3,4,5,6,7,8,9)
create_subset(9,x,3)

```
```{r weight function}
triwts <- function(distances){
  #allocate weights vector
  wts <- double(length = length(distances))
  
  for (i in 1:length(distances)){
    if (abs(distances[i]) <= 1){
      wts[i] <- (1-abs(distances[i])**3)**3
    }
    else
      wts[i] <- 0
  }
  return (wts)
}
dist <- c(0.7866237, 0.3744029, 0.168412, 0.0000000, 0.6660479, 0.7498743, 1.0000000)
triwts(dist)
```


```{r}
library(ggplot2)
load("ozone.RData")
data("ozone")

ggplot(ozone, aes(x = temperature, y = ozone)) + theme_bw() + geom_point()
```

```{r}
poly1 <- lm(ozone ~ temperature, data = ozone)
predicted_df <- data.frame(mpg_pred = predict(poly1, ozone), temp=ozone$)

ggplot(ozone, aes(x = temperature, y = ozone)) + theme_bw() + geom_point()
  + geom_line(color='red', data = ozone, aes(x= poly1))

```



